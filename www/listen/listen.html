<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Show Audio</title>
  <style>
    :root{
      --bg:#0f1115;
      --card:#171a21;
      --ink:#e9eef7;
      --muted:#9aa6b2;
      --accent:#00e5ff;
      --bad:#ff4d4d;
      --ok:#4dff88;
    }
    *{ box-sizing:border-box; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink); }
    .wrap{ max-width:720px; margin:0 auto; padding:18px; }
    .header{ text-align:center; margin:10px 0 18px; }
    .header img{ width:86px; height:86px; border-radius:18px; box-shadow:0 8px 28px rgba(0,0,0,.35); }
    h1{ margin:12px 0 6px; font-size:34px; letter-spacing:.3px; color:var(--accent); }
    .sub{ margin:0; color:var(--muted); font-size:14px; }
    .card{
      background:var(--card); border:1px solid rgba(255,255,255,.06);
      border-radius:16px; padding:16px; margin-top:16px; box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .card:first-of-type{ margin-top:0; }
    .section-title{ margin:0 0 10px; font-size:16px; color:var(--accent); }
    button{
      font-size:16px; padding:12px 16px; border-radius:12px;
      border:2px solid var(--accent); background:#11141a; color:var(--ink);
      cursor:pointer; width:100%;
    }
    button:active{ transform:scale(.99); }
    button:disabled{ opacity:.5; cursor:default; }
    .row{ display:flex; gap:10px; margin-top:10px; }
    .row button{ width:50%; }
    .pill{
      display:inline-flex; gap:8px; align-items:center;
      border:1px solid rgba(255,255,255,.08);
      border-radius:999px; padding:8px 12px; color:var(--muted); font-size:13px;
      background:rgba(0,0,0,.18);
    }
    .dot{ width:10px; height:10px; border-radius:50%; background:#666; }
    .dot.ok{ background:var(--ok); }
    .dot.bad{ background:var(--bad); }
    .grid{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    .kv{ background:rgba(0,0,0,.14); border:1px solid rgba(255,255,255,.06); border-radius:12px; padding:10px 12px; }
    .k{ font-size:12px; color:var(--muted); }
    .v{ margin-top:4px; font-size:14px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .small{ margin-top:12px; font-size:12px; color:var(--muted); line-height:1.4; }
    .footer{ margin-top:14px; text-align:center; font-size:12px; color:var(--muted); opacity:.85; }
    audio{ width:100%; margin-top:12px; }
    select{
      width:100%; font-size:16px; padding:10px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); color:var(--ink);
      cursor:pointer;
    }
    input[type="text"],input[type="password"]{
      width:100%; font-size:16px; padding:10px 12px; border-radius:10px;
      border:1px solid rgba(255,255,255,.12); background:rgba(0,0,0,.18); color:var(--ink);
    }
    .btn-sm{ font-size:14px; padding:10px 14px; margin-top:10px; }
    .status-msg{ margin-top:8px; font-size:12px; padding:8px; border-radius:8px; display:none; }
    .status-msg.success{ background:rgba(77,255,136,.15); color:var(--ok); }
    .status-msg.error{ background:rgba(255,77,77,.15); color:var(--bad); }
    .opts-toggle{
      text-align:center; cursor:pointer; padding:12px;
      background:rgba(0,0,0,.14); border:1px solid rgba(255,255,255,.06);
      border-radius:12px; color:var(--muted); font-size:13px;
    }
    .opts-toggle:hover{ background:rgba(0,0,0,.22); }
    .opts-body{ display:none; margin-top:12px; }
    .opts-body.open{ display:block; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="header">
    <img src="logo.png" alt="Undocumented Engineer" />
    <h1>Show Audio</h1>
    <p class="sub">Show owner controls. Tap anywhere to enable audio.</p>
  </div>

  <!-- Playback Control — always visible -->
  <div class="card">
    <h3 class="section-title">Playback</h3>
    <select id="seqSelect"><option value="">Loading...</option></select>
    <div class="row">
      <button id="startSeq">Start</button>
      <button id="stopSeq">Stop</button>
    </div>
    <div id="seqStatus" class="status-msg"></div>
  </div>

  <!-- Sync Status -->
  <div class="card">
    <div class="row" style="margin-top:0;">
      <button id="mute">Mute</button>
      <button id="resync">Resync</button>
    </div>

    <span class="pill" style="margin-top:12px; display:inline-flex;"><span id="dot" class="dot"></span><span id="state">Idle</span></span>

    <audio id="player" preload="auto" playsinline></audio>

    <div class="grid">
      <div class="kv"><div class="k">Track</div><div class="v" id="track">&mdash;</div></div>
      <div class="kv"><div class="k">Error</div><div class="v" id="err">&mdash;</div></div>
      <div class="kv"><div class="k">Rate</div><div class="v" id="rate">&mdash;</div></div>
      <div class="kv"><div class="k">Poll</div><div class="v" id="poll">&mdash;</div></div>
    </div>

    <div class="small">
      If audio is silent on iPhone, check the ringer switch and volume.
      You may need to stay on this page (some phones pause background audio).
    </div>

    <div class="footer" id="ver">Version: (loading&hellip;)</div>
  </div>

  <!-- Options — collapsible -->
  <div class="card" id="optionsCard" style="display:none;">
    <div class="opts-toggle" id="optsToggle">&#9660; Options</div>
    <div class="opts-body" id="optsBody">

      <h3 class="section-title" style="margin-top:12px;">Sync Settings</h3>

      <p class="small" style="margin-top:0;">Sync mode</p>
      <select id="syncMode">
        <option value="poll" selected>HTTP Polling (standard)</option>
        <option value="sse">SSE Frame-Lock (audio in FSEQ)</option>
      </select>

      <p class="small" style="margin-top:10px;">Hard seek threshold (HTTP polling mode only)</p>
      <select id="seekThreshold">
        <option value="2.0">Relaxed — &gt; 2.0 s</option>
        <option value="1.0" selected>Normal — &gt; 1.0 s</option>
        <option value="0.5">Tight — &gt; 0.5 s</option>
        <option value="0.25">Strict — &gt; 0.25 s</option>
        <option value="0.1">Precision — &gt; 0.1 s</option>
        <option value="0">Disabled — soft sync only</option>
      </select>

      <div class="grid" style="margin-top:12px;">
        <div class="kv"><div class="k">Learned Drift</div><div class="v" id="learnDrift">&mdash;</div></div>
        <div class="kv"><div class="k">Corrections</div><div class="v" id="learnCount">&mdash;</div></div>
      </div>
      <button class="btn-sm" id="resetLearning">Reset Learning Data</button>

      <div id="sseStats" style="display:none; margin-top:14px;">
        <h3 class="section-title">SSE Frame-Lock Stats</h3>
        <div class="grid">
          <div class="kv"><div class="k">SSE Status</div><div class="v" id="sseStatus">&mdash;</div></div>
          <div class="kv"><div class="k">Buffer</div><div class="v" id="sseBuffer">&mdash;</div></div>
          <div class="kv"><div class="k">Frames Rx</div><div class="v" id="sseFrames">&mdash;</div></div>
          <div class="kv"><div class="k">Drops</div><div class="v" id="sseDrops">&mdash;</div></div>
        </div>
      </div>

      <div id="wifiSection">
        <h3 class="section-title" style="margin-top:18px;">WiFi AP Settings</h3>

        <p class="small" style="margin-top:0;">Network name (SSID)</p>
        <input type="text" id="newSSID" placeholder="SHOW_AUDIO" autocomplete="off">
        <button class="btn-sm" id="changeSSID">Change SSID</button>
        <div id="ssidStatus" class="status-msg"></div>

        <p class="small" style="margin-top:14px;">Password (8-63 characters)</p>
        <input type="password" id="newPass" placeholder="New password" autocomplete="new-password">
        <button class="btn-sm" id="changePass">Change Password</button>
        <div id="passStatus" class="status-msg"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  // ====== Config ======
  const STATUS_URL = "./status.php";
  const POLL_MS = 250;
  const SEEK_COOLDOWN_MS = 2000;
  const STORAGE_KEY = "eavesdrop_sync";

  // ====== UI refs ======
  const dot = document.getElementById("dot");
  const stateEl = document.getElementById("state");
  const trackEl = document.getElementById("track");
  const errEl = document.getElementById("err");
  const rateEl = document.getElementById("rate");
  const pollEl = document.getElementById("poll");
  const verEl = document.getElementById("ver");
  const muteBtn = document.getElementById("mute");
  const resyncBtn = document.getElementById("resync");
  const audio = document.getElementById("player");
  const seekThresholdEl = document.getElementById("seekThreshold");
  const learnDriftEl = document.getElementById("learnDrift");
  const learnCountEl = document.getElementById("learnCount");
  const resetLearningBtn = document.getElementById("resetLearning");
  const syncModeEl = document.getElementById("syncMode");
  const sseStatsEl = document.getElementById("sseStats");
  const sseStatusEl = document.getElementById("sseStatus");
  const sseBufferEl = document.getElementById("sseBuffer");
  const sseFramesEl = document.getElementById("sseFrames");
  const sseDropsEl = document.getElementById("sseDrops");

  // ====== Persistent learning store ======
  function loadLearning(){
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw){ const d = JSON.parse(raw); return d && typeof d === "object" ? d : {}; }
    } catch(_){}
    return {};
  }
  function saveLearning(obj){
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(obj)); } catch(_){}
  }

  let learned = loadLearning();
  // learned.driftRate   = ms/sec the client drifts from server (positive = client runs fast)
  // learned.driftWeight = confidence weight (number of samples that built this estimate)
  // learned.corrections = total hard seeks performed (lifetime)
  // learned.seekThreshold = last chosen threshold
  if(typeof learned.driftRate !== "number") learned.driftRate = 0;
  if(typeof learned.driftWeight !== "number") learned.driftWeight = 0;
  if(typeof learned.corrections !== "number") learned.corrections = 0;
  if(typeof learned.seekThreshold === "string") seekThresholdEl.value = learned.seekThreshold;

  function getSeekThreshold(){
    return parseFloat(seekThresholdEl.value);
  }

  seekThresholdEl.addEventListener("change", () => {
    learned.seekThreshold = seekThresholdEl.value;
    saveLearning(learned);
  });

  // ====== State ======
  let audioUnlocked = false;
  let muted = false;
  let currentBase = "";
  let pollTimer = null;
  let haveMetadata = false;
  let lastSeekMs = 0;

  // SSE Frame-Lock state (declared early, used by sync/mute handlers)
  let sseActive = false;
  let sseEventSource = null;
  let sseAudioCtx = null;
  let sseScriptNode = null;
  let sseRingBuffer = null;
  let sseRingWrite = 0;
  let sseRingRead = 0;
  let sseRingSize = 0;
  let sseFrameCount = 0;
  let sseDropCount = 0;
  let sseFppHost = "";

  // Clock offset estimation
  let clockOffset = 0;
  let clockOffsetValid = false;
  const OFFSET_HISTORY_SIZE = 8;
  let offsetHistory = [];

  // Drift learning — per-session observations
  let driftSamples = [];           // {t: timestamp, err: errorSec}
  const DRIFT_WINDOW_MS = 15000;   // measure drift over 15-second windows
  const DRIFT_SAMPLE_MIN = 10;     // need at least 10 samples to estimate
  let sessionDriftRate = null;     // ms/sec drift observed this session

  function setDot(mode){
    dot.classList.remove("ok","bad");
    if(mode==="ok") dot.classList.add("ok");
    if(mode==="bad") dot.classList.add("bad");
  }

  function setState(text, ok){
    stateEl.textContent = text;
    setDot(ok ? "ok" : (ok===false ? "bad" : ""));
  }

  function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }

  // ====== Audio unlock on first user interaction ======
  function unlockAudio(){
    if(audioUnlocked) return;
    audioUnlocked = true;
    try {
      audio.muted = true;
      const p = audio.play();
      if(p && typeof p.then === 'function'){
        p.then(() => { audio.pause(); audio.currentTime = 0; audio.muted = false; })
         .catch(() => { audio.muted = false; });
      } else {
        audio.muted = false;
      }
    } catch(_){ audio.muted = false; }
  }
  document.addEventListener("click", unlockAudio, { once: true });
  document.addEventListener("touchstart", unlockAudio, { once: true });

  // ====== Clock offset ======
  function updateClockOffset(serverMs, clientSendMs, rtt){
    const sample = serverMs - clientSendMs - (rtt / 2);
    offsetHistory.push(sample);
    if(offsetHistory.length > OFFSET_HISTORY_SIZE) offsetHistory.shift();
    const sorted = [...offsetHistory].sort((a,b) => a - b);
    const median = sorted[Math.floor(sorted.length / 2)];
    if(!clockOffsetValid){
      clockOffset = median;
      clockOffsetValid = true;
    } else {
      clockOffset = clockOffset * 0.7 + median * 0.3;
    }
  }

  // ====== Drift learning ======
  function recordDriftSample(errSec){
    const now = performance.now();
    driftSamples.push({ t: now, err: errSec });
    // Trim old samples outside the window
    const cutoff = now - DRIFT_WINDOW_MS;
    while(driftSamples.length > 0 && driftSamples[0].t < cutoff) driftSamples.shift();

    if(driftSamples.length >= DRIFT_SAMPLE_MIN){
      // Linear regression: drift rate = slope of error over time
      const n = driftSamples.length;
      let sumT = 0, sumE = 0, sumTE = 0, sumTT = 0;
      for(let i = 0; i < n; i++){
        const t = (driftSamples[i].t - driftSamples[0].t) / 1000; // seconds
        const e = driftSamples[i].err * 1000; // ms
        sumT += t; sumE += e; sumTE += t * e; sumTT += t * t;
      }
      const denom = n * sumTT - sumT * sumT;
      if(Math.abs(denom) > 0.001){
        sessionDriftRate = (n * sumTE - sumT * sumE) / denom; // ms/sec

        // Blend session observation into persistent learned rate
        // Use exponential weighting: new observations matter more when learned weight is low
        const blendAlpha = Math.min(0.5, 1 / (1 + learned.driftWeight * 0.1));
        learned.driftRate = learned.driftRate * (1 - blendAlpha) + sessionDriftRate * blendAlpha;
        learned.driftWeight = Math.min(learned.driftWeight + 0.1, 200);
        saveLearning(learned);
      }
    }
  }

  function updateLearningUI(){
    const dr = learned.driftRate;
    if(learned.driftWeight > 0){
      const sign = dr >= 0 ? "+" : "";
      learnDriftEl.textContent = sign + dr.toFixed(2) + " ms/s";
    } else {
      learnDriftEl.textContent = "learning...";
    }
    learnCountEl.textContent = learned.corrections.toString();
  }

  // ====== Compute FPP target position in seconds ======
  function getTargetSec(msg){
    const nowMs = Date.now();
    const serverMs = Number(msg.server_ms);
    const rawPosMs = Number(msg.pos_ms || 0);
    let targetMs = rawPosMs;
    if(Number.isFinite(serverMs) && serverMs > 1e12 && Math.abs(nowMs - serverMs) < 300000){
      let elapsed = clockOffsetValid ? ((nowMs + clockOffset) - serverMs) : (nowMs - serverMs);
      if(!Number.isFinite(elapsed)) elapsed = 0;
      elapsed = clamp(elapsed, 0, 1500);
      targetMs = rawPosMs + elapsed;

      // Apply learned drift compensation: if we know the client drifts,
      // pre-correct by nudging the target in the opposite direction.
      // Scale by how long since we last hard-seeked (drift accumulates over time).
      if(learned.driftWeight > 1 && lastSeekMs > 0){
        const sinceSyncSec = (nowMs - lastSeekMs) / 1000;
        // driftRate is ms/sec the error grows; subtract it to compensate
        targetMs -= learned.driftRate * sinceSyncSec;
      }
    }
    return targetMs / 1000.0;
  }

  // ====== Soft sync: compute ideal playbackRate to converge ======
  function computeSoftRate(errSec){
    // Proportional correction: adjust rate to close the gap over ~2 seconds
    // errSec > 0 means we're behind → speed up; errSec < 0 → slow down
    const correction = clamp(errSec / 2.0, -0.05, 0.05);
    // Add learned drift compensation as a steady-state offset
    const driftComp = (learned.driftWeight > 1) ? (learned.driftRate / -1000) : 0;
    return clamp(1.0 + correction + driftComp, 0.9, 1.1);
  }

  // ====== Sync ======
  function sync(msg){
    // In SSE mode, still update track name and state from polling, but skip audio sync
    trackEl.textContent = msg.base || "\u2014";

    if(sseActive){
      // SSE mode: polling only provides metadata, audio is frame-locked via SSE
      if(msg.state === "stop" || !msg.base){
        setState("Idle (SSE)", null);
      } else if(msg.state === "pause"){
        setState("Paused (SSE)", true);
      } else {
        setState("Playing (SSE)", true);
      }
      errEl.textContent = "frame-locked";
      rateEl.textContent = "1.000x";
      return;
    }

    // --- Stop state: pause and reset ---
    if(msg.state === "stop" || !msg.base){
      if(!audio.paused) audio.pause();
      audio.currentTime = 0;
      audio.playbackRate = 1.0;
      currentBase = "";
      haveMetadata = false;
      driftSamples = [];
      setState("Idle", null);
      errEl.textContent = "\u2014";
      rateEl.textContent = "\u2014";
      return;
    }

    // --- Pause state ---
    if(msg.state === "pause"){
      if(!audio.paused) audio.pause();
      audio.playbackRate = 1.0;
      driftSamples = [];
      setState("Paused", true);
      return;
    }

    // --- Playing ---
    setState("Playing", true);

    // Track change — load new source
    if(msg.base && msg.base !== currentBase){
      currentBase = msg.base;
      haveMetadata = false;
      driftSamples = [];
      audio.src = msg.mp3_url || "";
      audio.load();
      audio.addEventListener("loadedmetadata", function onMeta(){
        audio.removeEventListener("loadedmetadata", onMeta);
        haveMetadata = true;
      });
      return;
    }

    // Wait for metadata
    if(!haveMetadata || !Number.isFinite(audio.duration) || audio.duration <= 0) return;

    const targetSec = getTargetSec(msg);
    const localSec = audio.currentTime || 0;
    const errSec = targetSec - localSec;

    errEl.textContent = (errSec >= 0 ? "+" : "") + (errSec * 1000).toFixed(0) + " ms";

    const absErr = Math.abs(errSec);
    const nowMs = Date.now();
    const threshold = getSeekThreshold();

    // Record error for drift learning (only when playing and not right after a seek)
    if((nowMs - lastSeekMs) > SEEK_COOLDOWN_MS){
      recordDriftSample(errSec);
    }

    // Hard seek: if enabled and error exceeds threshold
    if(threshold > 0 && absErr > threshold && (nowMs - lastSeekMs) > SEEK_COOLDOWN_MS){
      audio.currentTime = clamp(targetSec, 0, Math.max(0, audio.duration - 0.1));
      audio.playbackRate = 1.0;
      lastSeekMs = nowMs;
      learned.corrections++;
      saveLearning(learned);
      driftSamples = []; // reset drift window after a hard seek
      if(audio.paused && audioUnlocked) audio.play().catch(() => {});
      rateEl.textContent = "1.000x (seek)";
      updateLearningUI();
      return;
    }

    // Soft sync: adjust playback rate to converge
    const rate = computeSoftRate(errSec);
    audio.playbackRate = rate;
    rateEl.textContent = rate.toFixed(3) + "x";

    if(audio.paused && audioUnlocked) audio.play().catch(() => {});
    updateLearningUI();
  }

  // ====== Polling ======
  async function tick(){
    const t0 = Date.now();
    try {
      const r = await fetch(STATUS_URL + "?ts=" + t0, { cache: "no-store" });
      if(!r.ok) throw new Error("HTTP " + r.status);
      const msg = await r.json();
      const t1 = Date.now();
      const rtt = t1 - t0;
      pollEl.textContent = rtt + " ms";

      if(msg.server_ms && rtt > 0 && rtt < 500){
        updateClockOffset(msg.server_ms, t0, rtt);
      }

      sync(msg);
    } catch(e){
      setState("Disconnected", false);
    }
  }

  function startPolling(){
    if(pollTimer) return;
    pollTimer = setInterval(tick, POLL_MS);
    tick();
  }

  // ====== UI events ======
  muteBtn.addEventListener("click", () => {
    muted = !muted;
    muteBtn.textContent = muted ? "Unmute" : "Mute";
    audio.muted = muted;
    // Also mute/unmute SSE audio
    if(sseAudioCtx){
      if(muted) sseAudioCtx.suspend();
      else sseAudioCtx.resume();
    }
  });

  resyncBtn.addEventListener("click", () => {
    if(!haveMetadata || !currentBase) return;
    lastSeekMs = 0;
    driftSamples = [];
  });

  resetLearningBtn.addEventListener("click", () => {
    learned.driftRate = 0;
    learned.driftWeight = 0;
    learned.corrections = 0;
    driftSamples = [];
    sessionDriftRate = null;
    saveLearning(learned);
    updateLearningUI();
  });

  // Fetch version
  fetch("./version.php?t=" + Date.now()).then(r => r.json()).then(v => {
    verEl.textContent = "Eavesdrop v" + (v.eavesdrop || "?") + " | FPP v" + (v.fpp || "?");
  }).catch(() => { verEl.textContent = "Version: unknown"; });

  // Init learning UI
  updateLearningUI();

  // Start polling immediately (always runs for metadata even in SSE mode)
  startPolling();

  // Init SSE mode if previously selected
  if(syncModeEl.value === "sse"){
    setSyncMode("sse");
  }

  // ====== Admin: Playback Controls ======
  function showStatus(el, msg, ok){
    el.textContent = msg;
    el.className = "status-msg " + (ok ? "success" : "error");
    el.style.display = "block";
    setTimeout(() => { el.style.display = "none"; }, 5000);
  }

  async function adminPost(data){
    const fd = new FormData();
    for(const k in data) fd.append(k, data[k]);
    const r = await fetch("./admin.php", { method: "POST", body: fd });
    return await r.json();
  }

  const seqSelect = document.getElementById("seqSelect");
  const startSeqBtn = document.getElementById("startSeq");
  const stopSeqBtn = document.getElementById("stopSeq");
  const seqStatus = document.getElementById("seqStatus");

  // Load playlists + sequences on page load
  (async function loadSequences(){
    try {
      const res = await adminPost({ action: "get_sequences" });
      if(!res.success) return;
      seqSelect.innerHTML = '<option value="">-- Select --</option>';
      if(Array.isArray(res.playlists) && res.playlists.length > 0){
        const grp = document.createElement("optgroup");
        grp.label = "Playlists";
        res.playlists.forEach(s => {
          const o = document.createElement("option");
          o.value = s; o.textContent = s;
          grp.appendChild(o);
        });
        seqSelect.appendChild(grp);
      }
      if(Array.isArray(res.sequences) && res.sequences.length > 0){
        const grp = document.createElement("optgroup");
        grp.label = "Sequences";
        res.sequences.forEach(s => {
          const o = document.createElement("option");
          o.value = s; o.textContent = s;
          grp.appendChild(o);
        });
        seqSelect.appendChild(grp);
      }
      // Always show Options card (sync settings are always relevant)
      document.getElementById("optionsCard").style.display = "";
      if(res.has_wlan1){
        if(res.current_ssid) document.getElementById("newSSID").placeholder = res.current_ssid;
      } else {
        // Hide WiFi section if no wlan1
        document.getElementById("wifiSection").style.display = "none";
      }
    } catch(e){ seqSelect.innerHTML = '<option value="">Failed to load</option>'; }
  })();

  startSeqBtn.addEventListener("click", async () => {
    const seq = seqSelect.value;
    if(!seq){ showStatus(seqStatus, "Select a playlist or sequence first", false); return; }
    startSeqBtn.disabled = true; startSeqBtn.textContent = "Starting...";
    try {
      const res = await adminPost({ action: "start_sequence", sequence: seq });
      showStatus(seqStatus, res.success ? "Started: " + seq : (res.error || "Failed"), res.success);
    } catch(e){ showStatus(seqStatus, "Network error", false); }
    startSeqBtn.disabled = false; startSeqBtn.textContent = "Start";
  });

  stopSeqBtn.addEventListener("click", async () => {
    stopSeqBtn.disabled = true; stopSeqBtn.textContent = "Stopping...";
    try {
      const res = await adminPost({ action: "stop_playback" });
      showStatus(seqStatus, res.success ? "Stopped" : (res.error || "Failed"), res.success);
    } catch(e){ showStatus(seqStatus, "Network error", false); }
    stopSeqBtn.disabled = false; stopSeqBtn.textContent = "Stop";
  });

  // ====== SSE Frame-Lock Audio Decoder ======
  const SSE_URL = "./sse.php";
  const SSE_SAMPLE_RATE = 44100;
  const SSE_FPS = 40;
  const SSE_SAMPLES_PER_FRAME = Math.floor(SSE_SAMPLE_RATE / SSE_FPS); // 1102
  const SSE_CHANNELS_PER_FRAME = 2 + (SSE_SAMPLES_PER_FRAME * 2);      // 2206
  const SSE_SYNC_HI = 0xAA;
  const SSE_SYNC_LO = 0x55;

  function sseInitAudio(){
    if(sseAudioCtx) return;
    sseAudioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SSE_SAMPLE_RATE });

    // Ring buffer: hold ~2 seconds of audio
    sseRingSize = SSE_SAMPLE_RATE * 2;
    sseRingBuffer = new Float32Array(sseRingSize);
    sseRingWrite = 0;
    sseRingRead = 0;

    // ScriptProcessorNode for audio output (widely compatible)
    const bufSize = 2048;
    sseScriptNode = sseAudioCtx.createScriptProcessor(bufSize, 0, 1);
    sseScriptNode.onaudioprocess = function(e){
      const output = e.outputBuffer.getChannelData(0);
      for(let i = 0; i < output.length; i++){
        if(sseRingRead < sseRingWrite){
          output[i] = sseRingBuffer[sseRingRead % sseRingSize];
          sseRingRead++;
        } else {
          output[i] = 0; // underrun — silence
        }
      }
    };
    sseScriptNode.connect(sseAudioCtx.destination);
  }

  function sseDecodePCMFrame(bytes){
    // bytes: Uint8Array of channel data for one frame
    // Validate sync marker
    if(bytes.length < 4) return null;
    if(bytes[0] !== SSE_SYNC_HI || bytes[1] !== SSE_SYNC_LO) return null;

    // Calculate samples from actual data length
    const numSamples = Math.floor((bytes.length - 2) / 2);
    const samples = new Float32Array(numSamples);
    for(let i = 0; i < numSamples; i++){
      const off = 2 + (i * 2);
      const hi = bytes[off];
      const lo = bytes[off + 1];
      let val = (hi << 8) | lo;
      // Convert unsigned back to signed 16-bit
      if(val >= 32768) val -= 65536;
      samples[i] = val / 32768.0; // normalize to [-1, 1]
    }
    return samples;
  }

  function ssePushSamples(samples){
    if(!sseRingBuffer) return;
    for(let i = 0; i < samples.length; i++){
      sseRingBuffer[sseRingWrite % sseRingSize] = samples[i];
      sseRingWrite++;
    }
    // Prevent buffer overflow: if write gets too far ahead, advance read
    if(sseRingWrite - sseRingRead > sseRingSize){
      sseRingRead = sseRingWrite - sseRingSize;
      sseDropCount++;
    }
  }

  function sseHandleFrame(event){
    try {
      // Base64 decode the frame data from sse.php
      const raw = atob(event.data);
      const bytes = new Uint8Array(raw.length);
      for(let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);

      const samples = sseDecodePCMFrame(bytes);
      if(samples){
        ssePushSamples(samples);
        sseFrameCount++;
      }
    } catch(e){
      // Ignore parse errors
    }
  }

  function sseConnect(){
    const url = SSE_URL + "?channels=" + SSE_CHANNELS_PER_FRAME + "&fps=" + SSE_FPS;
    sseStatusEl.textContent = "Connecting...";

    try {
      sseEventSource = new EventSource(url);

      sseEventSource.onopen = function(){
        sseStatusEl.textContent = "Connected";
        sseStatusEl.style.color = "var(--ok)";
        sseInitAudio();
        if(sseAudioCtx && sseAudioCtx.state === "suspended"){
          sseAudioCtx.resume();
        }
      };

      // Named events from sse.php
      sseEventSource.addEventListener("frame", sseHandleFrame);

      sseEventSource.addEventListener("seq_open", function(e){
        // FSEQ file opened — log metadata
        try {
          const info = JSON.parse(e.data);
          sseStatusEl.textContent = "Playing: " + (info.file || "?");
          sseStatusEl.style.color = "var(--ok)";
        } catch(_){}
      });

      sseEventSource.addEventListener("idle", function(){
        sseStatusEl.textContent = "Idle (waiting)";
        sseStatusEl.style.color = "var(--muted)";
      });

      sseEventSource.addEventListener("no_audio", function(e){
        try {
          const info = JSON.parse(e.data);
          sseStatusEl.textContent = info.msg || "No audio FSEQ";
          sseStatusEl.style.color = "var(--muted)";
        } catch(_){
          sseStatusEl.textContent = "No audio FSEQ";
          sseStatusEl.style.color = "var(--muted)";
        }
      });

      sseEventSource.addEventListener("error", function(e){
        if(e.data){
          try {
            const info = JSON.parse(e.data);
            sseStatusEl.textContent = "Error: " + (info.msg || "unknown");
          } catch(_){
            sseStatusEl.textContent = "SSE error";
          }
        } else {
          sseStatusEl.textContent = "Disconnected";
        }
        sseStatusEl.style.color = "var(--bad)";
      });

      sseEventSource.onerror = function(){
        sseStatusEl.textContent = "Disconnected";
        sseStatusEl.style.color = "var(--bad)";
      };
    } catch(e){
      sseStatusEl.textContent = "Failed: " + e.message;
      sseStatusEl.style.color = "var(--bad)";
    }
  }

  function sseDisconnect(){
    if(sseEventSource){
      sseEventSource.close();
      sseEventSource = null;
    }
    if(sseScriptNode){
      sseScriptNode.disconnect();
      sseScriptNode = null;
    }
    if(sseAudioCtx){
      sseAudioCtx.close();
      sseAudioCtx = null;
    }
    sseRingBuffer = null;
    sseRingWrite = 0;
    sseRingRead = 0;
    sseFrameCount = 0;
    sseDropCount = 0;
    sseStatusEl.textContent = "--";
    sseStatusEl.style.color = "";
  }

  function sseUpdateStats(){
    if(!sseActive) return;
    const buffered = sseRingWrite - sseRingRead;
    const bufMs = Math.round((buffered / SSE_SAMPLE_RATE) * 1000);
    sseBufferEl.textContent = bufMs + " ms";
    sseFramesEl.textContent = sseFrameCount.toString();
    sseDropsEl.textContent = sseDropCount.toString();
  }

  // SSE stats update timer
  let sseStatsTimer = null;

  function setSyncMode(mode){
    if(mode === "sse"){
      // Switch to SSE mode
      sseActive = true;
      sseStatsEl.style.display = "";
      // Pause HTTP polling audio
      if(!audio.paused) audio.pause();
      audio.style.display = "none";
      sseConnect();
      sseStatsTimer = setInterval(sseUpdateStats, 250);
      setState("SSE Mode", true);
    } else {
      // Switch to HTTP polling mode
      sseActive = false;
      sseStatsEl.style.display = "none";
      audio.style.display = "";
      sseDisconnect();
      if(sseStatsTimer){ clearInterval(sseStatsTimer); sseStatsTimer = null; }
    }
  }

  // Restore saved sync mode
  if(learned.syncMode === "sse") syncModeEl.value = "sse";

  syncModeEl.addEventListener("change", () => {
    learned.syncMode = syncModeEl.value;
    saveLearning(learned);
    setSyncMode(syncModeEl.value);
  });

  // ====== Options: Toggle ======
  const optsToggle = document.getElementById("optsToggle");
  const optsBody = document.getElementById("optsBody");
  optsToggle.addEventListener("click", () => {
    const open = optsBody.classList.toggle("open");
    optsToggle.innerHTML = open ? "&#9650; Options" : "&#9660; Options";
  });

  // -- SSID --
  const newSSIDInput = document.getElementById("newSSID");
  const changeSSIDBtn = document.getElementById("changeSSID");
  const ssidStatus = document.getElementById("ssidStatus");

  changeSSIDBtn.addEventListener("click", async () => {
    const ssid = newSSIDInput.value.trim();
    if(!ssid){ showStatus(ssidStatus, "Enter an SSID", false); return; }
    if(ssid.length > 32){ showStatus(ssidStatus, "SSID must be 1-32 characters", false); return; }
    changeSSIDBtn.disabled = true; changeSSIDBtn.textContent = "Changing...";
    try {
      const res = await adminPost({ action: "change_ssid", ssid: ssid });
      if(res.success){
        showStatus(ssidStatus, res.message || "SSID changed!", true);
        newSSIDInput.value = "";
        newSSIDInput.placeholder = ssid;
      } else {
        showStatus(ssidStatus, res.error || "Failed", false);
      }
    } catch(e){ showStatus(ssidStatus, "Network error", false); }
    changeSSIDBtn.disabled = false; changeSSIDBtn.textContent = "Change SSID";
  });

  // -- Password --
  const newPassInput = document.getElementById("newPass");
  const changePassBtn = document.getElementById("changePass");
  const passStatus = document.getElementById("passStatus");

  changePassBtn.addEventListener("click", async () => {
    const pw = newPassInput.value;
    if(pw.length < 8 || pw.length > 63){
      showStatus(passStatus, "Password must be 8-63 characters", false); return;
    }
    changePassBtn.disabled = true; changePassBtn.textContent = "Changing...";
    try {
      const res = await adminPost({ action: "change_password", password: pw });
      if(res.success){
        showStatus(passStatus, "Password changed! Reconnect with new password.", true);
        newPassInput.value = "";
      } else {
        showStatus(passStatus, res.error || "Failed", false);
      }
    } catch(e){ showStatus(passStatus, "Network error", false); }
    changePassBtn.disabled = false; changePassBtn.textContent = "Change Password";
  });
})();
</script>
</body>
</html>
